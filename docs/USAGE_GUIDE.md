# Руководство по использованию Raymarching Demo

## Обзор

Это приложение демонстрирует реализацию техники raymarching/raytracing с использованием OpenCL для ускорения на GPU и Pygame для GUI интерфейса.

## Что такое Raymarching?

Raymarching - это техника рендеринга 3D сцен, где вместо традиционной триангуляции используются математические функции для описания геометрии (SDF - Signed Distance Functions). Эта техника особенно популярна в демосцене и shader-программировании.

## Особенности реализации

### OpenCL Ядро (`shaders/raymarch.cl`)
- **Distance Functions**: Функции расстояния для примитивов (сфера, куб, тор)
- **Scene SDF**: Комбинирование объектов сцены
- **Raymarching**: Алгоритм трассировки лучей по SDF
- **Освещение**: Простая модель освещения с диффузным и зеркальным отражением

### Python Компоненты
- **`raymarcher.py`**: Главный класс OpenCL рендерера
- **`gui.py`**: Pygame интерфейс с управлением камерой
- **`main.py`**: Точка входа с проверкой зависимостей
- **`scenes/`**: Определения сцен и объектов

## Управление

### Движение камеры
- **W/A/S/D**: Движение вперед/влево/назад/вправо
- **Space**: Движение вверх
- **Shift**: Движение вниз

### Поворот камеры
- **Мышь**: Свободный обзор (нажмите F3 для захвата мыши) - стандартное управление
- **Стрелки**: Поворот камеры

### Горячие клавиши
- **F1**: Показать/скрыть FPS
- **F2**: Показать/скрыть информацию о камере
- **F3**: Включить/выключить захват мыши
- **F11**: Переключить полноэкранный режим
- **F12**: Переключить разрешение экрана
- **R**: Сбросить позицию камеры
- **ESC**: Выход из полноэкранного режима или приложения

### Полноэкранный режим
- **F11** - переключение между оконным и полноэкранным режимом
- **F12** - переключение между предустановленными разрешениями
- **ESC** - выход из полноэкранного режима (не закрывает приложение)
- Автоматическое изменение разрешения рендеринга под размер экрана
- Поддержка высоких разрешений (протестировано до 2560x1440)
- Оконный режим поддерживает изменение размера окна

### Настройка разрешения
- **Командная строка**: `python main.py --resolution 1920x1080`
- **Полноэкранный запуск**: `python main.py --fullscreen --auto-resolution`
- **Быстрый запуск**: `python launcher.py fullscreen`
- **Предустановки**: 800x600, 1024x768, 1280x720, 1366x768, 1920x1080, 2560x1440, Нативное разрешение

## Архитектура

### OpenCL Pipeline
1. **Инициализация**: Создание контекста OpenCL и очереди команд
2. **Компиляция ядра**: Загрузка и компиляция .cl файла
3. **Настройка буферов**: Создание буфера для выходного изображения
4. **Рендеринг**: Выполнение ядра для каждого пикселя
5. **Результат**: Копирование данных обратно в CPU

### Raymarching Алгоритм
```
for each pixel (x, y):
    ray_direction = calculate_ray_direction(x, y, camera)
    distance = 0
    for max_steps:
        position = camera_pos + ray_direction * distance
        scene_distance = scene_sdf(position)
        distance += scene_distance
        if scene_distance < threshold:
            // Hit surface - calculate lighting
            return lighting_calculation(position)
        if distance > max_distance:
            // Ray escaped - return background
            return background_color
```

## Производительность

### Оптимизации
- **GPU ускорение**: Все вычисления рендеринга выполняются на GPU
- **Эффективные SDF**: Оптимизированные функции расстояния
- **Ограничение шагов**: Максимум 100 шагов raymarching
- **Early termination**: Остановка при достижении поверхности

### Мониторинг
- **FPS счетчик**: Отображение частоты кадров в реальном времени
- **Время рендеринга**: Измерение времени выполнения кадра
- **Информация о камере**: Позиция и углы поворота

## Расширение функциональности

### Добавление новых примитивов
Создайте новую SDF функцию в `raymarch.cl`:
```c
float sdCylinder(float3 p, float h, float r) {
    float2 d = abs((float2)(length(p.xz), p.y)) - (float2)(r, h);
    return min(max(d.x, d.y), 0.0f) + length(max(d, 0.0f));
}
```

### Создание новых сцен
Добавьте новую сцену в `scenes/scenes.py`:
```python
def create_my_scene() -> Scene:
    scene = Scene("My Scene")
    scene.add_object('sphere', (0.0, 0.0, 0.0), {'radius': 1.0})
    scene.add_light((5.0, 5.0, 5.0))
    return scene
```

### Материалы и текстуры
Расширьте систему освещения для поддержки различных материалов:
- Добавьте параметры материала в структуру объектов
- Модифицируйте функцию lighting() в OpenCL ядре
- Реализуйте процедурные текстуры через SDF

## Устранение проблем

### OpenCL не найден
- Убедитесь, что установлены драйверы GPU
- Проверьте доступность платформ OpenCL
- Используйте CPU fallback если GPU недоступен

### Низкая производительность
- Уменьшите разрешение окна
- Снизите максимальное количество шагов raymarching
- Упростите scene SDF функцию

### Ошибки компиляции ядра
- Проверьте синтаксис OpenCL C
- Убедитесь в совместимости с версией OpenCL
- Используйте простые математические функции

## Технические детали

### Системные требования
- **Python**: 3.8+
- **GPU**: С поддержкой OpenCL 1.2+
- **RAM**: Минимум 4GB
- **OS**: Windows/Linux/macOS

### Зависимости
- **PyOpenCL**: Интерфейс Python для OpenCL
- **NumPy**: Численные вычисления и массивы
- **Pygame**: GUI и обработка событий
- **Pillow**: Обработка изображений (опционально)

Это приложение демонстрирует мощь современных GPU для real-time рендеринга и может служить основой для более сложных проектов в области компьютерной графики.
